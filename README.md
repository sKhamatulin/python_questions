# __Вопросы и ответы на собеседование Python Junior Developer Backend__

## __Почему понравился Python? Какие недостатки?__

Python - это интерпретируемый, динамический, объектно-ориентированный язык программирования, который имеет простой и понятный синтаксис. Его основные преимущества:

* Простота в изучении и использовании.
* Обширная библиотека, которая позволяет использовать сторонние модули для решения задач.
* Высокая скорость разработки благодаря динамической типизации и автоматическому управлению памятью.
* Кроссплатформенность.
* Язык, на котором можно реализовать все от простых скриптов до сложных приложений.

Недостатки Python:

* Python может быть не самым быстрым языком, особенно при работе с большими объемами данных или приложениями, требующими высокой производительности.
* Он может быть не лучшим выбором для создания высокопроизводительных приложений, таких как игры или системы реального времени.
* Python также может быть недостаточно безопасным для некоторых приложений, таких как системы финансового учета.

## __PEP8, pylint/flake8, black__

PEP 8 - это стандартный стиль кодирования для языка Python, который устанавливает рекомендации по использованию отступов, длине строки, именам переменных, комментариям и др. PEP 8 - это не обязательный стандарт, но его рекомендуется следовать для облегчения чтения и сопровождения кода.

Pylint и Flake8 - это инструменты статического анализа кода, которые проверяют соответствие кода PEP 8 и наличие других проблем в коде, таких как ошибки и предупреждения. Они используются для улучшения качества кода и обнаружения ошибок до запуска приложения.

Black - это инструмент автоматического форматирования кода Python, который приводит код в соответствие с PEP 8. Black используется для обеспечения согласованности кода и уменьшения вероятности возникновения ошибок из-за форматирования.

## __Изменяемые и неизменяемые типы.__

В Python все объекты делятся на изменяемые и неизменяемые типы. Изменяемые объекты могут быть изменены после создания, а неизменяемые – нет. Некоторые примеры неизменяемых объектов в Python:

* Числа (int, float, complex)
* Булевы значения (bool)
* Строки (str)
* Кортежи (tuple)
* Фиксированные множества (frozenset)

А изменяемыми объектами являются, например:

* Списки (list)
* Множества (set)
* Словари (dict)

Разница между изменяемыми и неизменяемыми объектами заключается в том, что для изменяемых объектов операция изменения может привести к созданию нового объекта, в то время как для неизменяемых объектов изменение значений ведет к созданию нового объекта. При работе с изменяемыми объектами следует быть осторожным, чтобы не создавать ненужных копий объектов и не тратить дополнительную память.

## __ХЭШ__

Хеширование (хеш) – это процесс преобразования произвольного объекта в числовое значение фиксированной длины, которое используется для быстрого поиска объекта в словаре или множестве. Хеширование работает только с неизменяемыми объектами, так как в случае изменения объекта его хеш также изменится.

## __В чем разница между списком и массивом__

Список (list) в Python – это упорядоченная изменяемая коллекция объектов произвольных типов. Списки могут содержать объекты разных типов и допускают повторения элементов. Они поддерживают различные методы, такие как append(), insert(), remove() и другие, которые позволяют изменять список.

Массив (array) в Python – это коллекция элементов одного типа, которая может быть более эффективной, чем списки, когда речь идет об использовании больших объемов данных. Они представляют собой специальный тип списка, который оптимизирован для работы с числовыми данными. Основное отличие массива от списка заключается в том, что массив занимает меньше памяти и имеет более эффективный доступ к элементам.

## __Где поиск быстрее всего: словарь, список, кортеж, множество (set)__

Словарь (dict) – это неупорядоченная коллекция элементов, которые связаны между собой ключами. Ключи должны быть уникальными, а значения могут быть произвольного тип

* Словарь (dict) обеспечивает наилучшую производительность при поиске элемента по ключу, т.к. внутри используется хеш-таблица, что позволяет достигать почти константного времени поиска O(1).
* Множество (set) также использует хеш-таблицу, и поиск по множеству также имеет временную сложность O(1).
* Список (list) и кортеж (tuple) не используют хеш-таблицы, и приходится перебирать все элементы до тех пор, пока не будет найден нужный. Сложность поиска по списку и кортежу O(n), где n - количество элементо

## __Отличие None и NoneType:__

* None - это единственный экземпляр объекта класса NoneType, который используется в Python для представления отсутствия значения или нулевого значения. None является объектом, который можно присвоить переменной или использовать в качестве возвращаемого значения функции.
* NoneType - это тип объекта, который представляет отсутствие значения. Если переменная не имеет значения, она считается объектом типа NoneType. NoneType - это встроенный тип данных в Python, который определяется как None. **class** .

## **__Исключения. Какие есть? Зачем нужны? Как обрабатывать? Зачем else в try..except__**

В Python есть множество встроенных исключений, которые возникают при выполнении программы. Некоторые из них:

* `SyntaxError` - возникает при ошибке в синтаксисе программы
* `NameError` - возникает, когда неопределенное имя используется в программе
* `TypeError` - возникает, когда операция не может быть выполнена из-за несоответствия типов
* `ValueError` - возникает, когда функции переданы аргументы с корректным типом, но неверное значение

Исключения используются для того, чтобы обрабатывать ошибки и не допускать краха программы. Их можно обработать с помощью конструкции `try..except`.

Пример:

```python
try:
    # определяет блок кода, который должен быть выполнен
except SomeException:
    # определяет блок кода, который будет выполнен, если возникнет исключени
else:
    # определяет блок кода, который будет выполнен, если в блоке try не было выброшено исключени
finally:
    # определяет блок кода, который будет выполнен в любом случа
```

### **__ARGS, KWARGS__**

`*args` и `**kwargs` - это специальные параметры в Python функциях. `*args` позволяет передавать переменное количество позиционных аргументов, а `**kwargs` - переменное количество именованных аргументов.

```python
def my_function(*args, **kwargs):
```

`*args` передает переменное количество позиционных аргументов в функцию в виде кортежа, а `**kwargs` передает переменное количество именованных аргументов в виде словаря. Эти параметры могут использоваться в функции для передачи произвольного количества аргументов.

## **__Почему изменяемый объект по умолчанию в аргументе функции - плохо?__**

Когда в качестве значения по умолчанию в аргументе функции используется изменяемый объект (например, список или словарь), то каждый вызов функции будет использовать один и тот же объект в качестве значения по умолчанию. Если внутри функции изменяется значение этого объекта, то изменение отразится на следующем вызове функции.

Например, рассмотрим следующую функцию, которая принимает список в качестве значения по умолчани

Например, предположим, что у нас есть следующая функция:

```python
def append_to_list(value, lst=[]):
    lst.append(value)
    return lst
```

Если мы вызовем эту функцию несколько раз без указания списка:

```python
print(append_to_list(1))
print(append_to_list(2))
```

Мы получим следующий результат:

```python
[1]
[1, 2]
```

Как видим, наш список увеличивается с каждым вызовом функции.

Чтобы избежать этой проблемы, можно использовать неизменяемый тип данных, такой как кортеж, в качестве значения по умолчанию. Кроме того, можно использовать значение None в качестве значения по умолчанию и проверять, было ли передано значение для данного аргумента. Если значение не было передано, можно создать новый объект внутри функции.

Пример использования значения None:

```python
def append_to_list(value, lst=None):
    if lst is None:
        lst = []
    lst.append(value)
    return lst
```

## __LAMBDA__

Lambda-функции (анонимные функции) в Python - это функции, которые могут содержать только одно выражение. Они обычно используются вместо определения обычной функции, когда мы хотим передать функцию в качестве аргумента в другую функцию. Вот несколько примеров:

1. Простой пример, который возводит число в квадрат:

   ```python
   square = lambda x: x**2
   print(square(5))  # Output: 25
   ```
2. Пример с использованием нескольких аргументов:

   ```python
   sum = lambda x, y: x + y
   print(sum(2, 3))  # Output: 5
   ```
3. Пример с использованием лямбда-функции в качестве аргумента для функции `map()`, которая применяет функцию к каждому элементу последовательности:

   ```python
   my_list = [1, 2, 3, 4, 5]
   squared_list = list(map(lambda x: x**2, my_list))
   print(squared_list)  # Output: [1, 4, 9, 16, 25]
   ```

## __Как отсортировать список словарей по одному из ключей:__

Чтобы отсортировать список словарей по значению определенного ключа, мы можем использовать метод `sorted()` с параметром `key`, который указывает функцию для извлечения значения ключа для сортировки. Например, чтобы отсортировать список словарей по ключу 'age', мы можем написать:

```python
list_of_dicts = [{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 20}, {'name': 'Charlie', 'age': 30}]
sorted_list = sorted(list_of_dicts, key=lambda x: x['age'])
```

Если нужна сортировка по убыванию, можно добавить параметр `reverse=True`:

```python
sorted_list = sorted(list_of_dicts, key=lambda x: x['age'], reverse=True)
```

## __Map, Filter, Reduce в Python:__

`map()`, `filter()` и `reduce()` - это встроенные функции Python, которые могут применять функции к последовательностям и сводить их к одному значению.

`map()` - применяет функцию к каждому элементу последовательности и возвращает итератор со значениями, полученными в результате.

```python
numbers = [1, 2, 3, 4]
squared_numbers = map(lambda x: x**2, numbers)
print(list(squared_numbers))  # [1, 4, 9, 16]
```

`filter()` - применяет функцию к каждому элементу последовательности и возвращает итератор со значениями, для которых функция вернула `True`.

```python
numbers = [1, 2, 3, 4]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # [2, 4]
```

`reduce()` - сводит последовательность к единственному значению, применяя функцию к двум элементам и повторяя этот процесс до тех пор, пока не останется один элемент.

```python
from functools import reduce
numbers = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # 24
```

## __CONTEXT MANAGER ENTER, EXIT__

Context Manager - это объект, который управляет блоком кода с определенным контекстом выполнения, то есть контекст менеджер позволяет определить начало и конец определенной области действия. Контекст менеджеры позволяют открывать и закрывать файлы, блокировать и разблокировать ресурсы, устанавливать и снимать флаги и т.д.

Для создания контекст менеджера нужно определить два метода:  **enter** () и  **exit** ().

Метод  **enter** () вызывается при входе в блок контекста и возвращает объект, который будет использоваться в контексте.

Метод  **exit** () вызывается при выходе из блока контекста и используется для очистки или освобождения ресурсов.

Пример использования контекст менеджера для открытия файла:

```python
with open('example.txt', 'w') as f:
    f.write('Hello, World!')
```

При выходе из блока контекста файл будет автоматически закрыт.

### __Передача аргументов в функцию - что по ссылке, а что по значению__

При передаче аргументов в функцию, в Python происходит передача по ссылке на объект. Если объект является неизменяемым, то при передаче он передается по значению. Если объект является изменяемым, то при передаче он передается по ссылке.

Например, если мы передаем список в функцию и изменяем его внутри функции, то изменения будут видны и за пределами функции:

```python
def modify_list(lst):
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list) # [1, 2, 3, 4]
```

Однако, если мы передаем число или строку в функцию и изменяем его внутри функции, то изменения не будут видны за пределами функции:

```python
def modify_string(s):
    s += ' World'

my_string = 'Hello'
modify_string(my_string)
print(my_string) # Hello
```

В этом случае функция создает новый объект со своей копией аргумента, изменения внутри функции не влияют на оригинальный объект.

## __Как создать копию объекта. Отличие copy от deepcopy__

В Python для создания копии объекта можно использовать функции `copy` и `deepcopy` из модуля `copy`.

Функция `copy` создает поверхностную копию объекта. Это означает, что создается новый объект, который содержит ссылки на те же объекты, что и оригинал. Если оригинал содержит изменяемые объекты (например, списки или словари), то изменения в копии будут отражаться и на оригинале.

Пример создания поверхностной копии списка:

```python
import copy

original_list = [1, 2, 3]
copied_list = copy.copy(original_list)
```

Функция `deepcopy` создает полную копию объекта. Это означает, что создается новый объект, который содержит копии всех объектов, на которые ссылается оригинал. Если оригинал содержит изменяемые объекты, то изменения в копии не будут отражаться на оригинале.

Пример создания глубокой копии списка:

```python
import copy

original_list = [1, [2, 3], 4]
copied_list = copy.deepcopy(original_list)
```

Отличие между `copy` и `deepcopy` заключается в том, что `copy` создает поверхностную копию, а `deepcopy` создает полную копию объекта.

## Что такое итератор и генератор. Как определить (__iter__, next. def: yield)

Итератор и генератор - это концепции, связанные с последовательностями в Python.

Итератор - это объект, который предоставляет последовательность элементов, и который может быть произведен только один раз. Итераторы часто используются в циклах for, где каждый раз извлекается следующий элемент из итератора. Итераторы реализуют методы __iter__() и __next__(). Метод __iter__() возвращает сам итератор объекта, а метод __next__() возвращает следующий элемент в последовательности. Когда больше элементов не осталось, __next__() вызывает исключение StopIteration.

Пример:

```python
my_list = [1, 2, 3]
my_iterator = iter(my_list)

print(next(my_iterator)) # 1
print(next(my_iterator)) # 2
print(next(my_iterator)) # 3
```

Генератор - это способ создания итератора в Python. Генераторы позволяют нам определить функцию, которая работает как итератор, и автоматически генерирует значения при вызове метода `__next__()` для каждого элемента в последовательности. Генераторы могут быть созданы с помощью ключевого слова `yield`.

Пример:

```python
def my_generator():
  yield 1
  yield 2
  yield 3

for value in my_generator():
  print(value) # 1, 2, 3
```

В этом примере функция `my_generator()` содержит ключевое слово `yield`, которое генерирует последовательность значений. Когда мы вызываем функцию `my_generator()` в цикле for, каждый вызов функции генерирует следующее значение в последовательности, начиная с 1, 2 и 3.

## __list/dict comprehension__

List/dict comprehension - это способ создания нового списка/словаря на основе существующих данных.

List comprehension позволяет создать новый список, пройдя по элементам существующего списка и применив к ним какое-то выражение.

Пример:

```python
numbers = [1, 2, 3, 4, 5]
squares = [num ** 2 for num in numbers]
print(squares) # [1, 4, 9, 16, 25]
```

В данном примере мы создали новый список `squares`, проходя по элементам списка `numbers` и возводя их в квадрат.

Dict comprehension позволяет создать новый словарь, пройдя по элементам существующего списка и применив к ним какое-то выражение.

Пример:

```python
words = ["hello", "world", "python"]
word_lengths = {word: len(word) for word in words}
print(word_lengths) # {"hello": 5, "world": 5, "python": 6}
```

В данном примере мы создали новый словарь `word_lengths`, проходя по элементам списка `words` и создавая пару ключ-значение, где ключом является элемент списка, а значением - его длина.

List/dict comprehension - это компактный и удобный способ создания новых списков/словарей, их можно использовать вместо циклов и условных операторов.

## __Что такое декораторы__

```python
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```

В этом примере мы определяем функцию-декоратор `my_decorator`, которая принимает другую функцию в качестве аргумента, создает новую функцию `wrapper`, которая добавляет новый функционал, и возвращает эту новую функцию. Затем мы используем декоратор `@my_decorator` перед функцией `say_hello`, чтобы применить декоратор к этой функции.

При запуске этого кода, мы увидим следующий результат:

```python
Something is happening before the function is called.
Hello!
Something is happening after the function is called.
```

Это показывает, что наш декоратор успешно добавил новый функционал к функции `say_hello`.

Декораторы могут применяться к любой функции, методу класса или даже классу в целом. Они могут быть полезны для многих задач, таких как авторизация, кэширование, логирование, обработка исключений и т.д.

## __Замыкания в python__

Замыкание (closure) в Python - это функция, которая запоминает значения из объемлющей области видимости, даже если эта область видимости уже закончилась свою работу. Другими словами, замыкание - это функция, которая запоминает значения переменных, которые были доступны в момент ее создания.

Для создания замыкания в Python необходимо внутри функции объявить вложенную функцию, которая будет использовать переменные из внешней функции. Затем, возвращается вложенная функция. При этом, внешняя функция может принимать аргументы, которые будут использоваться во вложенной функции.

Пример использования замыкания:

```python
def outer_func(x):
    def inner_func(y):
        return x + y
    return inner_func

closure_func = outer_func(10)
result = closure_func(5) # result = 15
```

В этом примере `outer_func` возвращает вложенную функцию `inner_func`, которая складывает значение аргумента `x` из внешней функции с переданным аргументом `y`. После этого, создается замыкание `closure_func`, которое содержит значение `x = 10` из внешней функции. При вызове `closure_func` с аргументом `5`, вложенная функция `inner_func` складывает `x` и `y` и возвращает `15`.

Замыкания используются в Python для создания функций, которые сохраняют состояние между вызовами. Также замыкания могут быть использованы для скрытия переменных и функций внутри модуля.

## __На дискуссию: поддерживает ли питон ооп в полной мере__

Python - это язык, который полностью поддерживает объектно-ориентированное программирование (ООП). В Python все сущности, включая функции и модули, являются объектами, и могут иметь свойства и методы. ООП в Python реализовано на основе классов, которые являются основными элементами ООП.

Python поддерживает все основные принципы ООП, такие как инкапсуляция, наследование и полиморфизм. Классы в Python могут иметь атрибуты, методы, конструкторы, свойства и декораторы. Также существуют специальные методы, которые позволяют создавать собственные объекты и переопределять стандартное поведение объектов, например, методы **str** и  **repr** .

В Python также существует возможность использовать множественное наследование, что может быть полезным в различных сценариях. Python также поддерживает абстрактные классы и интерфейсы, что облегчает проектирование классов.

Таким образом, можно утверждать, что Python полностью поддерживает ООП и является очень гибким и мощным языком программирования, который позволяет использовать ООП в различных сценариях.
