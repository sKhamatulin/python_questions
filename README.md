# __Вопросы и ответы на собеседование Python Junior Developer Backend__

## __Почему понравился Python? Какие недостатки?__

Python - это интерпретируемый, динамический, объектно-ориентированный язык программирования, который имеет простой и понятный синтаксис. Его основные преимущества:

* Простота в изучении и использовании.
* Обширная библиотека, которая позволяет использовать сторонние модули для решения задач.
* Высокая скорость разработки благодаря динамической типизации и автоматическому управлению памятью.
* Кроссплатформенность.
* Язык, на котором можно реализовать все от простых скриптов до сложных приложений.

Недостатки Python:

* Python может быть не самым быстрым языком, особенно при работе с большими объемами данных или приложениями, требующими высокой производительности.
* Он может быть не лучшим выбором для создания высокопроизводительных приложений, таких как игры или системы реального времени.
* Python также может быть недостаточно безопасным для некоторых приложений, таких как системы финансового учета.

## __PEP8, pylint/flake8, black__

PEP 8 - это стандартный стиль кодирования для языка Python, который устанавливает рекомендации по использованию отступов, длине строки, именам переменных, комментариям и др. PEP 8 - это не обязательный стандарт, но его рекомендуется следовать для облегчения чтения и сопровождения кода.

Pylint и Flake8 - это инструменты статического анализа кода, которые проверяют соответствие кода PEP 8 и наличие других проблем в коде, таких как ошибки и предупреждения. Они используются для улучшения качества кода и обнаружения ошибок до запуска приложения.

Black - это инструмент автоматического форматирования кода Python, который приводит код в соответствие с PEP 8. Black используется для обеспечения согласованности кода и уменьшения вероятности возникновения ошибок из-за форматирования.

## __Изменяемые и неизменяемые типы.__

В Python все объекты делятся на изменяемые и неизменяемые типы. Изменяемые объекты могут быть изменены после создания, а неизменяемые – нет. Некоторые примеры неизменяемых объектов в Python:

* Числа (int, float, complex)
* Булевы значения (bool)
* Строки (str)
* Кортежи (tuple)
* Фиксированные множества (frozenset)

А изменяемыми объектами являются, например:

* Списки (list)
* Множества (set)
* Словари (dict)

Разница между изменяемыми и неизменяемыми объектами заключается в том, что для изменяемых объектов операция изменения может привести к созданию нового объекта, в то время как для неизменяемых объектов изменение значений ведет к созданию нового объекта. При работе с изменяемыми объектами следует быть осторожным, чтобы не создавать ненужных копий объектов и не тратить дополнительную память.

## __ХЭШ__

Хеширование (хеш) – это процесс преобразования произвольного объекта в числовое значение фиксированной длины, которое используется для быстрого поиска объекта в словаре или множестве. Хеширование работает только с неизменяемыми объектами, так как в случае изменения объекта его хеш также изменится.

## __В чем разница между списком и массивом__

Список (list) в Python – это упорядоченная изменяемая коллекция объектов произвольных типов. Списки могут содержать объекты разных типов и допускают повторения элементов. Они поддерживают различные методы, такие как append(), insert(), remove() и другие, которые позволяют изменять список.

Массив (array) в Python – это коллекция элементов одного типа, которая может быть более эффективной, чем списки, когда речь идет об использовании больших объемов данных. Они представляют собой специальный тип списка, который оптимизирован для работы с числовыми данными. Основное отличие массива от списка заключается в том, что массив занимает меньше памяти и имеет более эффективный доступ к элементам.

## __Где поиск быстрее всего: словарь, список, кортеж, множество (set)__

Словарь (dict) – это неупорядоченная коллекция элементов, которые связаны между собой ключами. Ключи должны быть уникальными, а значения могут быть произвольного тип

* Словарь (dict) обеспечивает наилучшую производительность при поиске элемента по ключу, т.к. внутри используется хеш-таблица, что позволяет достигать почти константного времени поиска O(1).
* Множество (set) также использует хеш-таблицу, и поиск по множеству также имеет временную сложность O(1).
* Список (list) и кортеж (tuple) не используют хеш-таблицы, и приходится перебирать все элементы до тех пор, пока не будет найден нужный. Сложность поиска по списку и кортежу O(n), где n - количество элементо

## __Отличие None и NoneType:__

* None - это единственный экземпляр объекта класса NoneType, который используется в Python для представления отсутствия значения или нулевого значения. None является объектом, который можно присвоить переменной или использовать в качестве возвращаемого значения функции.
* NoneType - это тип объекта, который представляет отсутствие значения. Если переменная не имеет значения, она считается объектом типа NoneType. NoneType - это встроенный тип данных в Python, который определяется как None. **class** .

## **__Исключения. Какие есть? Зачем нужны? Как обрабатывать? Зачем else в try..except__**

В Python есть множество встроенных исключений, которые возникают при выполнении программы. Некоторые из них:

* `SyntaxError` - возникает при ошибке в синтаксисе программы
* `NameError` - возникает, когда неопределенное имя используется в программе
* `TypeError` - возникает, когда операция не может быть выполнена из-за несоответствия типов
* `ValueError` - возникает, когда функции переданы аргументы с корректным типом, но неверное значение

Исключения используются для того, чтобы обрабатывать ошибки и не допускать краха программы. Их можно обработать с помощью конструкции `try..except`.

Пример:

```python
try:
    # определяет блок кода, который должен быть выполнен
except SomeException:
    # определяет блок кода, который будет выполнен, если возникнет исключени
else:
    # определяет блок кода, который будет выполнен, если в блоке try не было выброшено исключени
finally:
    # определяет блок кода, который будет выполнен в любом случа
```

### **__ARGS, KWARGS__**

`*args` и `**kwargs` - это специальные параметры в Python функциях. `*args` позволяет передавать переменное количество позиционных аргументов, а `**kwargs` - переменное количество именованных аргументов.

```python
def my_function(*args, **kwargs):
```

`*args` передает переменное количество позиционных аргументов в функцию в виде кортежа, а `**kwargs` передает переменное количество именованных аргументов в виде словаря. Эти параметры могут использоваться в функции для передачи произвольного количества аргументов.

## **__Почему изменяемый объект по умолчанию в аргументе функции - плохо?__**

Когда в качестве значения по умолчанию в аргументе функции используется изменяемый объект (например, список или словарь), то каждый вызов функции будет использовать один и тот же объект в качестве значения по умолчанию. Если внутри функции изменяется значение этого объекта, то изменение отразится на следующем вызове функции.

Например, рассмотрим следующую функцию, которая принимает список в качестве значения по умолчани

Например, предположим, что у нас есть следующая функция:

```python
def append_to_list(value, lst=[]):
    lst.append(value)
    return lst
```

Если мы вызовем эту функцию несколько раз без указания списка:

```python
print(append_to_list(1))
print(append_to_list(2))
```

Мы получим следующий результат:

```python
[1]
[1, 2]
```

Как видим, наш список увеличивается с каждым вызовом функции.

Чтобы избежать этой проблемы, можно использовать неизменяемый тип данных, такой как кортеж, в качестве значения по умолчанию. Кроме того, можно использовать значение None в качестве значения по умолчанию и проверять, было ли передано значение для данного аргумента. Если значение не было передано, можно создать новый объект внутри функции.

Пример использования значения None:

```python
def append_to_list(value, lst=None):
    if lst is None:
        lst = []
    lst.append(value)
    return lst
```

## __LAMBDA__

Lambda-функции (анонимные функции) в Python - это функции, которые могут содержать только одно выражение. Они обычно используются вместо определения обычной функции, когда мы хотим передать функцию в качестве аргумента в другую функцию. Вот несколько примеров:

1. Простой пример, который возводит число в квадрат:

   ```python
   square = lambda x: x**2
   print(square(5))  # Output: 25
   ```
2. Пример с использованием нескольких аргументов:

   ```python
   sum = lambda x, y: x + y
   print(sum(2, 3))  # Output: 5
   ```
3. Пример с использованием лямбда-функции в качестве аргумента для функции `map()`, которая применяет функцию к каждому элементу последовательности:

   ```python
   my_list = [1, 2, 3, 4, 5]
   squared_list = list(map(lambda x: x**2, my_list))
   print(squared_list)  # Output: [1, 4, 9, 16, 25]
   ```

## __Как отсортировать список словарей по одному из ключей:__

Чтобы отсортировать список словарей по значению определенного ключа, мы можем использовать метод `sorted()` с параметром `key`, который указывает функцию для извлечения значения ключа для сортировки. Например, чтобы отсортировать список словарей по ключу 'age', мы можем написать:

```python
list_of_dicts = [{'name': 'Alice', 'age': 25}, {'name': 'Bob', 'age': 20}, {'name': 'Charlie', 'age': 30}]
sorted_list = sorted(list_of_dicts, key=lambda x: x['age'])
```

Если нужна сортировка по убыванию, можно добавить параметр `reverse=True`:

```python
sorted_list = sorted(list_of_dicts, key=lambda x: x['age'], reverse=True)
```

## __Map, Filter, Reduce в Python:__

`map()`, `filter()` и `reduce()` - это встроенные функции Python, которые могут применять функции к последовательностям и сводить их к одному значению.

`map()` - применяет функцию к каждому элементу последовательности и возвращает итератор со значениями, полученными в результате.

```python
numbers = [1, 2, 3, 4]
squared_numbers = map(lambda x: x**2, numbers)
print(list(squared_numbers))  # [1, 4, 9, 16]
```

`filter()` - применяет функцию к каждому элементу последовательности и возвращает итератор со значениями, для которых функция вернула `True`.

```python
numbers = [1, 2, 3, 4]
even_numbers = filter(lambda x: x % 2 == 0, numbers)
print(list(even_numbers))  # [2, 4]
```

`reduce()` - сводит последовательность к единственному значению, применяя функцию к двум элементам и повторяя этот процесс до тех пор, пока не останется один элемент.

```python
from functools import reduce
numbers = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # 24
```

## __CONTEXT MANAGER ENTER, EXIT__

Context Manager - это объект, который управляет блоком кода с определенным контекстом выполнения, то есть контекст менеджер позволяет определить начало и конец определенной области действия. Контекст менеджеры позволяют открывать и закрывать файлы, блокировать и разблокировать ресурсы, устанавливать и снимать флаги и т.д.

Для создания контекст менеджера нужно определить два метода:  **enter** () и  **exit** ().

Метод  **enter** () вызывается при входе в блок контекста и возвращает объект, который будет использоваться в контексте.

Метод  **exit** () вызывается при выходе из блока контекста и используется для очистки или освобождения ресурсов.

Пример использования контекст менеджера для открытия файла:

```python
with open('example.txt', 'w') as f:
    f.write('Hello, World!')
```

При выходе из блока контекста файл будет автоматически закрыт.

### __Передача аргументов в функцию - что по ссылке, а что по значению__

При передаче аргументов в функцию, в Python происходит передача по ссылке на объект. Если объект является неизменяемым, то при передаче он передается по значению. Если объект является изменяемым, то при передаче он передается по ссылке.

Например, если мы передаем список в функцию и изменяем его внутри функции, то изменения будут видны и за пределами функции:

```python
def modify_list(lst):
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list) # [1, 2, 3, 4]
```

Однако, если мы передаем число или строку в функцию и изменяем его внутри функции, то изменения не будут видны за пределами функции:

```python
def modify_string(s):
    s += ' World'

my_string = 'Hello'
modify_string(my_string)
print(my_string) # Hello
```

В этом случае функция создает новый объект со своей копией аргумента, изменения внутри функции не влияют на оригинальный объект.

## __Как создать копию объекта. Отличие copy от deepcopy__

В Python для создания копии объекта можно использовать функции `copy` и `deepcopy` из модуля `copy`.

Функция `copy` создает поверхностную копию объекта. Это означает, что создается новый объект, который содержит ссылки на те же объекты, что и оригинал. Если оригинал содержит изменяемые объекты (например, списки или словари), то изменения в копии будут отражаться и на оригинале.

Пример создания поверхностной копии списка:

```python
import copy

original_list = [1, 2, 3]
copied_list = copy.copy(original_list)
```

Функция `deepcopy` создает полную копию объекта. Это означает, что создается новый объект, который содержит копии всех объектов, на которые ссылается оригинал. Если оригинал содержит изменяемые объекты, то изменения в копии не будут отражаться на оригинале.

Пример создания глубокой копии списка:

```python
import copy

original_list = [1, [2, 3], 4]
copied_list = copy.deepcopy(original_list)
```

Отличие между `copy` и `deepcopy` заключается в том, что `copy` создает поверхностную копию, а `deepcopy` создает полную копию объекта.

## Что такое итератор и генератор. Как определить (__iter__, next. def: yield)

Итератор и генератор - это концепции, связанные с последовательностями в Python.

Итератор - это объект, который предоставляет последовательность элементов, и который может быть произведен только один раз. Итераторы часто используются в циклах for, где каждый раз извлекается следующий элемент из итератора. Итераторы реализуют методы __iter__() и __next__(). Метод __iter__() возвращает сам итератор объекта, а метод __next__() возвращает следующий элемент в последовательности. Когда больше элементов не осталось, __next__() вызывает исключение StopIteration.

Пример:

```python
my_list = [1, 2, 3]
my_iterator = iter(my_list)

print(next(my_iterator)) # 1
print(next(my_iterator)) # 2
print(next(my_iterator)) # 3
```

Генератор - это способ создания итератора в Python. Генераторы позволяют нам определить функцию, которая работает как итератор, и автоматически генерирует значения при вызове метода `__next__()` для каждого элемента в последовательности. Генераторы могут быть созданы с помощью ключевого слова `yield`.

Пример:

```python
def my_generator():
  yield 1
  yield 2
  yield 3

for value in my_generator():
  print(value) # 1, 2, 3
```

В этом примере функция `my_generator()` содержит ключевое слово `yield`, которое генерирует последовательность значений. Когда мы вызываем функцию `my_generator()` в цикле for, каждый вызов функции генерирует следующее значение в последовательности, начиная с 1, 2 и 3.

## __list/dict comprehension__

List/dict comprehension - это способ создания нового списка/словаря на основе существующих данных.

List comprehension позволяет создать новый список, пройдя по элементам существующего списка и применив к ним какое-то выражение.

Пример:

```python
numbers = [1, 2, 3, 4, 5]
squares = [num ** 2 for num in numbers]
print(squares) # [1, 4, 9, 16, 25]
```

В данном примере мы создали новый список `squares`, проходя по элементам списка `numbers` и возводя их в квадрат.

Dict comprehension позволяет создать новый словарь, пройдя по элементам существующего списка и применив к ним какое-то выражение.

Пример:

```python
words = ["hello", "world", "python"]
word_lengths = {word: len(word) for word in words}
print(word_lengths) # {"hello": 5, "world": 5, "python": 6}
```

В данном примере мы создали новый словарь `word_lengths`, проходя по элементам списка `words` и создавая пару ключ-значение, где ключом является элемент списка, а значением - его длина.

List/dict comprehension - это компактный и удобный способ создания новых списков/словарей, их можно использовать вместо циклов и условных операторов.

## __Что такое декораторы__

```python
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
```

В этом примере мы определяем функцию-декоратор `my_decorator`, которая принимает другую функцию в качестве аргумента, создает новую функцию `wrapper`, которая добавляет новый функционал, и возвращает эту новую функцию. Затем мы используем декоратор `@my_decorator` перед функцией `say_hello`, чтобы применить декоратор к этой функции.

При запуске этого кода, мы увидим следующий результат:

```python
Something is happening before the function is called.
Hello!
Something is happening after the function is called.
```

Это показывает, что наш декоратор успешно добавил новый функционал к функции `say_hello`.

Декораторы могут применяться к любой функции, методу класса или даже классу в целом. Они могут быть полезны для многих задач, таких как авторизация, кэширование, логирование, обработка исключений и т.д.

## __Замыкания в python__

Замыкание (closure) в Python - это функция, которая запоминает значения из объемлющей области видимости, даже если эта область видимости уже закончилась свою работу. Другими словами, замыкание - это функция, которая запоминает значения переменных, которые были доступны в момент ее создания.

Для создания замыкания в Python необходимо внутри функции объявить вложенную функцию, которая будет использовать переменные из внешней функции. Затем, возвращается вложенная функция. При этом, внешняя функция может принимать аргументы, которые будут использоваться во вложенной функции.

Пример использования замыкания:

```python
def outer_func(x):
    def inner_func(y):
        return x + y
    return inner_func

closure_func = outer_func(10)
result = closure_func(5) # result = 15
```

В этом примере `outer_func` возвращает вложенную функцию `inner_func`, которая складывает значение аргумента `x` из внешней функции с переданным аргументом `y`. После этого, создается замыкание `closure_func`, которое содержит значение `x = 10` из внешней функции. При вызове `closure_func` с аргументом `5`, вложенная функция `inner_func` складывает `x` и `y` и возвращает `15`.

Замыкания используются в Python для создания функций, которые сохраняют состояние между вызовами. Также замыкания могут быть использованы для скрытия переменных и функций внутри модуля.

## __На дискуссию: поддерживает ли питон ооп в полной мере__

Python - это язык, который полностью поддерживает объектно-ориентированное программирование (ООП). В Python все сущности, включая функции и модули, являются объектами, и могут иметь свойства и методы. ООП в Python реализовано на основе классов, которые являются основными элементами ООП.

Python поддерживает все основные принципы ООП, такие как инкапсуляция, наследование и полиморфизм. Классы в Python могут иметь атрибуты, методы, конструкторы, свойства и декораторы. Также существуют специальные методы, которые позволяют создавать собственные объекты и переопределять стандартное поведение объектов, например, методы **str** и  **repr** .

В Python также существует возможность использовать множественное наследование, что может быть полезным в различных сценариях. Python также поддерживает абстрактные классы и интерфейсы, что облегчает проектирование классов.

Таким образом, можно утверждать, что Python полностью поддерживает ООП и является очень гибким и мощным языком программирования, который позволяет использовать ООП в различных сценариях.

## __Что делает функция dir__

В Python функция `dir()` используется для получения списка атрибутов и методов объекта. Она возвращает список строк, каждая из которых представляет собой имя атрибута или метода объекта.

Если вызвать функцию без аргументов, то она вернет список имен, определенных в текущей области видимости. Если передать в нее объект, то она вернет список всех атрибутов и методов этого объекта.

Например, для списка объектов, `dir()` покажет все методы, которые могут быть использованы со списком, такие как `append()`, `extend()`, `insert()`, `remove()`, `sort()` и т.д.

Пример использования `dir()` для списка:

```python
my_list = [1, 2, 3]
print(dir(my_list))


# ['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
```

Также можно использовать функцию `help()` с объектом, чтобы получить подробную информацию о каждом методе и атрибуте.

## __SLOTS__

`__slots__` - это механизм оптимизации памяти в Python. Он позволяет явно указать, какие атрибуты могут быть у экземпляров класса, что позволяет оптимизировать память, не выделяя лишних слотов для атрибутов.

Когда вы создаете экземпляр класса, Python выделяет определенное количество памяти для хранения атрибутов. Если вы определяете класс без использования `__slots__`, Python создаст словарь для каждого экземпляра, в котором будут храниться все его атрибуты. Это может потреблять много памяти, если у вас есть много экземпляров класса.

Когда вы определяете `__slots__` для класса, вы сообщаете Python, какие атрибуты будут у экземпляров класса. Это позволяет Python использовать массив вместо словаря для хранения атрибутов, что существенно экономит память.

Вот пример:

```python
class MyClass:
    __slots__ = ['name', 'value']
    def __init__(self, name, value):
        self.name = name
        self.value = value
```

В этом примере `__slots__` сообщает Python, что экземпляры класса могут иметь только два атрибута - `name` и `value`. Если вы попытаетесь установить атрибут, который не указан в `__slots__`, вы получите ошибку AttributeError.

Преимущества использования `__slots__`:

* Уменьшение использования памяти для экземпляров класса.
* Ускорение доступа к атрибутам объекта, поскольку Python использует массив вместо словаря.
* Защита от случайного создания новых атрибутов объекта.

Недостатки:

* Ограничение количества атрибутов экземпляра.
* Ограничение возможности наследования от классов, определенных с использованием `__slots__`.

## __Примеры композиции в python, магические методы__

Композиция в объектно-ориентированном программировании (ООП) - это паттерн проектирования, который позволяет создавать сложные объекты, объединяя их из более простых объектов. В Python композиция может быть реализована с использованием вложенных объектов или атрибутов класса, которые являются экземплярами других классов. Вот примеры композиции в Python:

Пример 1: Вложенные объекты

```python
class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self, brand, engine):
        self.brand = brand
        self.engine = engine

    def start(self):
        print(f"Starting {self.brand} car...")
        self.engine.start()

engine = Engine()
car = Car("Toyota", engine)
car.start()
```

В этом примере класс `Car` содержит объект класса `Engine` в качестве одного из своих атрибутов. Метод `start()` класса `Car` вызывает метод `start()` объекта `Engine`, реализуя композицию.

Пример 2: Атрибуты класса

```python
class Engine:
    def start(self):
        print("Engine started")

class Car:
    engine = Engine()

    def start(self):
        print("Starting car...")
        self.engine.start()

car = Car()
car.start()
```

В этом примере класс `Car` содержит атрибут класса `engine`, который является экземпляром класса `Engine`. Метод `start()` класса `Car` вызывает метод `start()` объекта `engine`, реализуя композицию.

Магические методы (или дандер-методы) в Python - это специальные методы, которые начинаются и заканчиваются двойными подчеркиваниями (например, `__init__()`, `__str__()`, `__add__()` и т. д.). Они позволяют определить поведение объектов в различных контекстах, таких как создание, преобразование в строку, сложение, сравнение и другие операции.

Пример использования магического метода `__str__()`:

```python
class Car:
    def __init__(self, brand, model):
        self.brand = brand
        self.model = model

    def __str__(self):
        return f"{self.brand} {self.model}"

car = Car("Toyota", "Camry")
print(car)  # Вывод: Toyota Camry
```

В этом примере метод `__str__()` позволяет определить, как объект класса `Car` будет преобразовываться в строку при вызове функции `print()`. Магические методы позволяют определить специальное поведение объектов в различных контекстах и являются мощным инструментом для настройки поведения классов в Python.

## __Счетчик ссылкок, GIL, getrefcount()__

Счетчик ссылок, GIL и getrefcount() - это связанные концепции в Python, которые имеют отношение к управлению памятью и параллелизму.

Счетчик ссылок - это механизм управления памятью в Python, который подсчитывает количество ссылок на объект. Когда объект создается, устанавливается начальное значение счетчика ссылок на 1. Каждый раз, когда ссылка на объект создается (например, когда переменная присваивается этому объекту), значение счетчика ссылок увеличивается на 1. Когда объект больше не нужен, значение счетчика ссылок уменьшается на 1. Когда значение счетчика ссылок становится равным нулю, объект удаляется из памяти автоматически. Это называется сборкой мусора.

GIL (Global Interpreter Lock) - это механизм в Python, который обеспечивает синхронизацию потоков в многопоточных приложениях. Это означает, что только один поток может выполняться в интерпретаторе Python в любой момент времени. Это ограничение было введено для обеспечения безопасности в работе с памятью и избежания состояний гонки (race conditions) в многопоточных приложениях.

getrefcount() - это функция из стандартной библиотеки Python, которая позволяет получить количество ссылок на объект в памяти. Эта функция может быть полезна при отладке и профилировании кода для определения, сколько ссылок на объект в настоящее время существует.

Как правило, вам не нужно беспокоиться о счетчике ссылок и GIL в обычных приложениях Python. Однако, в некоторых случаях, таких как работа с большими объемами данных или в высоконагруженных сетевых приложениях, эти концепции могут стать важными.

## __Потоки, процессы__

В Python существует несколько способов реализации многопоточности и многопроцессности.

Потоки (threads) - это средство организации многопоточности в Python. Потоки позволяют выполнять несколько задач одновременно в пределах одного процесса. В Python потоки могут быть созданы с помощью стандартной библиотеки threading.

Процессы (processes) - это отдельные экземпляры программы, которые могут выполняться одновременно. В Python процессы могут быть созданы с помощью стандартной библиотеки multiprocessing.

При использовании многопоточности или многопроцессности необходимо учитывать особенности работы интерпретатора Python, в частности, наличие GIL (Global Interpreter Lock), который предотвращает одновременное выполнение нескольких потоков на одном ядре процессора. В связи с этим, многопоточность может не дать значительного выигрыша в производительности в некоторых случаях.

## __Асинхронность: async/await, какая реализация асинхронности в asyncio, какая в tornado. Как лучше проектировать асинхронные приложения__

Асинхронное программирование - это подход к написанию программного кода, при котором задачи выполняются независимо друг от друга и не блокируют выполнение других задач. В Python для асинхронного программирования используются два подхода - asyncio и Tornado.

Asyncio - это библиотека Python, встроенная в стандартную библиотеку Python с версии 3.4, которая предоставляет средства для создания асинхронных приложений. Она основана на событийной модели и позволяет выполнять операции ввода-вывода (I/O) асинхронно и эффективно управлять несколькими задачами, используя один поток. Основным механизмом asyncio являются корутины, которые запускаются асинхронно и могут приостанавливать свое выполнение, чтобы уступить управление другим корутинам.

Пример использования asyncio:

```python
import asyncio

async def main():
    print('Hello')
    await asyncio.sleep(1)
    print('World')

asyncio.run(main())
```

Tornado - это фреймворк для создания асинхронных веб-приложений на Python, который также основан на событийной модели. Tornado предоставляет асинхронную обработку запросов HTTP, веб-сокетов, механизмы работы с базами данных и другие инструменты для создания высокопроизводительных веб-приложений.

Пример использования Tornado:

```python
import tornado.ioloop
import tornado.web

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hello, world")

def make_app():
    return tornado.web.Application([
        (r"/", MainHandler),
    ])

if __name__ == "__main__":
    app = make_app()
    app.listen(8888)
    tornado.ioloop.IOLoop.current().start()
```

При проектировании асинхронных приложений необходимо учитывать ряд особенностей:

* Операции ввода-вывода (I/O) должны быть асинхронными, чтобы не блокировать выполнение других задач.
* Необходимо управлять конкурентностью и синхронизацией данных.
* Необходимо использовать многопоточность или многопроцессность для максимальной производительности.

Для облегчения разработки асинхронных приложений в Python существует ряд библиотек и фреймворков, таких как FastAPI, Sanic, Quart, aiohttp, которые предоставляют дополнительные средства для работы с асинхронными операциями и упрощают разработку.

## __Зачем нужны Middleware__

Middleware - это компоненты программного обеспечения, которые предоставляются между клиентом и приложением, и позволяют изменять поведение приложения или запроса в процессе обработки запроса.

Они могут выполнять различные задачи, такие как авторизация, логирование, кеширование, обработка ошибок и многое другое. Применение Middleware позволяет избежать дублирования кода и улучшить модульность приложения.

В веб-приложениях Middleware обычно используется для обработки запросов и ответов, но они могут быть использованы и в других типах приложений. В целом, Middleware дает возможность внедрять дополнительную логику в приложение без изменения его основной структуры.

## __Как происходит http запрос, заголовки, методы, коды ответа__

HTTP (Hypertext Transfer Protocol) - это протокол передачи данных, используемый в Интернете для передачи гипертекстовых документов, таких как HTML, CSS, JS и т.д. Протокол работает по схеме «клиент-сервер», где клиент посылает запрос, а сервер отвечает на него.

Каждый HTTP-запрос состоит из трех частей: запроса, заголовков и тела сообщения.

Запрос (Request):

1. Метод запроса (GET, POST, PUT, DELETE и т.д.) определяет действие, которое необходимо выполнить.
2. URL-адрес (Uniform Resource Locator) определяет ресурс, к которому обращается запрос.
3. Версия протокола HTTP, например, HTTP/1.1.

Пример HTTP-запроса:

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:110.0) Gecko/20100101 Firefox/110.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Upgrade-Insecure-Requests: 1
```

Заголовки (Headers):
Заголовки могут содержать различные параметры, такие как User-Agent, Accept, Content-Type, Content-Length, Cookie и многие другие.

Пример HTTP-заголовка:

```
Content-Type: application/json
```

Тело сообщения (Body):
Тело сообщения содержит данные, которые передаются в запросе, например, в POST-запросах.

Пример тела сообщения:

```json
{
  "username": "john_doe",
  "password": "p@ssw0rd"
}
```

HTTP-ответ состоит из трех частей: статусной строки, заголовков и тела сообщения.

Статусная строка:
Статусная строка состоит из трех частей: версии протокола, кода состояния и краткого текстового описания состояния.

Пример HTTP-статусной строки:

```
HTTP/1.1 200 OK
```

Заголовки (Headers):
Заголовки ответа содержат различные параметры, такие как Content-Type, Content-Length, Server и многие другие.

Пример HTTP-заголовка:

```
Content-Type: application/json
```

Тело сообщения (Body):
Тело сообщения содержит данные, которые возвращаются в ответ на запрос, например, HTML-страницы или JSON-данные.

Пример тела сообщения:

```json
{
  "status": "success",
  "data": {
    "user_id": 123,
    "username": "john_doe"
  }
}
```

Кроме того, в протоколе HTTP существует набор методов (GET, POST, PUT, DELETE и т.д.), которые определяют действия, которые должен выполнить сервер при обработке запроса. Например, метод GET используется для получения ресурса, а метод POST - для создания нового ресурса.

Когда клиент отправляет запрос на сервер, он включает в себя заголовки, которые содержат метаданные о запросе, например, тип контента, язык и т.д. Заголовки могут также содержать информацию о клиенте, например, тип браузера и операционную систему.

Когда сервер получает запрос, он выполняет определенные действия в зависимости от метода запроса и содержимого заголовков. Если сервер успешно обработал запрос, он отправляет клиенту ответ, который также содержит заголовки и содержимое ответа.

Коды ответа HTTP используются для обозначения статуса выполнения запроса, например, код 200 обозначает успешное выполнение запроса, а код 404 - ошибку, когда запрашиваемый ресурс не найден на сервере.

## __HTTP 301__

HTTP 301 - это статус-код ответа на HTTP-запрос, который обозначает, что запрашиваемый ресурс был перемещен на новый постоянный URL. Он также известен как "Перемещено навсегда".

При получении кода 301 клиентский агент должен автоматически перенаправить запрос на новый адрес, указанный в заголовке ответа Location. Это позволяет поисковым системам обновлять свои ссылки на ресурсы, а также предотвращать ошибки при обращении к ресурсам, которые были удалены или перемещены на новый адрес.

Кроме того, код 301 часто используется в SEO для перенаправления старых страниц на новые, чтобы сохранить их рейтинг в поисковых системах.

## __Типы авторизации__

В информационной безопасности существуют различные типы авторизации, которые используются для защиты конфиденциальных данных и ресурсов. Некоторые из наиболее распространенных типов авторизации включают в себя:

1. Basic Authentication - это самый простой тип авторизации, который включает передачу имени пользователя и пароля в виде незашифрованного текста в заголовке HTTP-запроса.
2. Token-based Authentication - этот тип авторизации включает передачу уникального токена вместо пароля, который обычно получается после успешной аутентификации пользователя. Токены могут быть временными или постоянными, и они используются для доступа к ресурсам и функциям, которые требуют аутентификации.
3. OAuth - это протокол авторизации, который позволяет пользователям разрешать доступ к своим аккаунтам на сторонних сайтах и приложениях. Он использует токены для аутентификации пользователя и получения доступа к ресурсам.
4. OpenID - это протокол, который используется для аутентификации пользователей, а не для авторизации. Он позволяет пользователям использовать одну учетную запись для доступа к различным ресурсам и приложениям.
5. SAML - это протокол, который используется для обмена аутентификационными данными между различными системами. Он использует XML для передачи информации об аутентификации и авторизации пользователей.
6. LDAP - это протокол, который используется для хранения и обмена информацией об аутентификации и авторизации пользователей в корпоративных сетях. Он обычно используется вместе с Active Directory и другими системами управления идентификацией и доступом.

## __Что такое, JWT, cookie__

JWT (JSON Web Token) и cookie — это два разных механизма аутентификации и авторизации.

JWT — это формат токена, который содержит утверждения (claims) о пользователе, которые могут использоваться для аутентификации и авторизации на сервере. Он представляет собой JSON-объект, который подписан цифровой подписью. Токен может быть передан между клиентом и сервером через HTTP-заголовок, параметры запроса или тело запроса. Поскольку токен подписан, сервер может проверить подлинность токена и использовать содержащиеся в нем утверждения для аутентификации пользователя.

Cookie — это небольшой файл, который сервер отправляет клиенту и который хранится в браузере клиента. Он содержит информацию, которую сервер может использовать для аутентификации пользователя на каждом запросе. Cookie может быть установлен с помощью заголовка Set-Cookie в HTTP-ответе сервера. Клиент должен отправить этот Cookie обратно на сервер при каждом запросе, чтобы сервер мог идентифицировать пользователя и предоставить ему соответствующие права доступа.

Различия между JWT и cookie:

* JWT — это токен, который передается между клиентом и сервером в HTTP-заголовке, параметрах запроса или теле запроса, в то время как cookie — это небольшой файл, который хранится на стороне клиента.
* JWT подписывается, что позволяет проверять его подлинность, в то время как cookie может быть подделано.
* JWT может быть использован для передачи данных, связанных с аутентификацией и авторизацией, в то время как cookie может содержать любую информацию, которую сервер решит сохранить.
* JWT не требует хранения на стороне сервера, в отличие от cookie, которые должны храниться на стороне сервера и могут занимать место в памяти или на диске.

## __REST, SOAP, JRPC__

REST, SOAP и gRPC являются протоколами для обмена данными между различными приложениями или сервисами.

REST (Representational State Transfer) - это стиль архитектуры, который использует HTTP-запросы для обмена данными. В REST-архитектуре каждый ресурс (например, объект или коллекция объектов) идентифицируется уникальным URL-адресом, а методы HTTP используются для указания действий, которые нужно выполнить с ресурсом (например, GET для получения данных, POST для создания нового ресурса, PUT для обновления существующего ресурса и т.д.).

SOAP (Simple Object Access Protocol) - это протокол для обмена структурированными сообщениями в формате XML. SOAP использует HTTP-протокол для транспортировки сообщений, но его основной целью является предоставление стандартизированного формата для описания функций, доступных через веб-сервисы.

gRPC - это современный, быстрый и эффективный протокол для обмена данными между клиентами и серверами, который основывается на протоколе буфера сообщений Google (protobuf). gRPC позволяет создавать многоязыковые и многоплатформенные приложения, обеспечивая эффективную сериализацию и передачу данных.

Каждый из этих протоколов имеет свои преимущества и недостатки, и выбор конкретного протокола зависит от конкретных требований проекта. REST-архитектура наиболее распространена и поддерживается большинством языков программирования и фреймворков. SOAP широко используется в больших корпоративных системах, где необходима строгая структурированность и надежность. gRPC наиболее эффективен при передаче больших объемов данных и высоконагруженных системах.

## __SWAGGER__

Swagger (сейчас он переименован в OpenAPI) - это язык описания API и набор инструментов для работы с этим описанием. С его помощью можно описывать методы, параметры и ответы API в формате YAML или JSON.

Swagger/OpenAPI позволяет автоматически генерировать документацию к API, а также генерировать код клиентских библиотек на разных языках программирования.

Основная цель Swagger/OpenAPI - упростить разработку и поддержку API, улучшить их документирование, и облегчить интеграцию различных сервисов и приложений.

## __CSRF, CSP__

CSRF (Cross-Site Request Forgery) и CSP (Content Security Policy) - это механизмы безопасности, используемые в веб-разработке.

CSRF - это атака, при которой злоумышленник заставляет пользователя выполнить нежелательное действие на веб-сайте без его согласия. Например, злоумышленник может отправить запрос от имени пользователя на сервер с целью изменения его пароля или отправки сообщения. Чтобы защититься от CSRF-атак, веб-приложения могут использовать токены CSRF, которые генерируются на стороне сервера и передаются на клиентскую сторону для каждого запроса. Токен CSRF проверяется на сервере, чтобы убедиться, что запрос был отправлен от действительного пользователя.

CSP - это политика безопасности контента, которая позволяет веб-разработчикам указать, какие ресурсы могут быть загружены на их веб-сайты. Это помогает предотвратить атаки, такие как XSS (Cross-Site Scripting), когда злоумышленник вставляет вредоносный скрипт на веб-страницу. С помощью CSP разработчики могут ограничить, какие ресурсы могут быть загружены на их сайты, включая скрипты, стили, изображения и другие ресурсы. Также можно указать, какие домены могут загружать ресурсы на веб-сайт. В результате, если на страницу попытаются добавить вредоносный скрипт из недоверенного домена, браузер его не выполнит.

В целом, использование CSP и CSRF-токенов может усилить безопасность веб-приложений и помочь защитить пользователей от вредоносных атак.

## __Чем принципиально отличаются Django и aiohttp__

Django и aiohttp - это два разных фреймворка для создания веб-приложений на Python, которые имеют свои особенности и подходы.

Django является полноценным фреймворком, который предоставляет множество функций и модулей для разработки веб-приложений. Он базируется на шаблонном подходе и использует концепцию Model-View-Controller (MVC) для разделения бизнес-логики, представления и данных. Django имеет встроенный ORM (Object-Relational Mapping), который упрощает работу с базами данных и позволяет использовать различные базы данных. Он также имеет встроенный механизм аутентификации и авторизации пользователей, поддержку межсайтовых запросов (CSRF) и многие другие функции, что делает его мощным инструментом для создания крупных веб-приложений.

С другой стороны, aiohttp - это асинхронный фреймворк, основанный на asyncio. Он позволяет создавать высокопроизводительные веб-приложения, используя асинхронные методы и механизмы. aiohttp предоставляет простой и гибкий интерфейс для создания HTTP-серверов и клиентов, а также поддерживает WebSocket-соединения. aiohttp также поддерживает многообразие аутентификации и авторизации пользователей, включая аутентификацию по токену и по cookie.

Таким образом, главное отличие между Django и aiohttp заключается в том, что Django предоставляет полноценный набор инструментов для создания веб-приложений, в то время как aiohttp сфокусирован на производительности и асинхронности, позволяя создавать легкие и масштабируемые веб-приложения.

## __Q в Django ORM__

Q объект в Django ORM представляет собой объект, который используется для создания сложных запросов с использованием операторов `OR`, `AND` и `NOT` в Django ORM. Он позволяет создавать динамические запросы и собирать их из нескольких фрагментов.

Например, если мы хотим найти все записи в базе данных, где `name` равно `Alice` ИЛИ `age` меньше 30, мы можем использовать Q объект:

```python
from django.db.models import Q

results = MyModel.objects.filter(Q(name='Alice') | Q(age__lt=30))
```

Здесь `Q(name='Alice')` и `Q(age__lt=30)` - это два объекта Q, объединенные оператором `|` (OR). Результат будет содержать все записи, удовлетворяющие одному из этих условий.

Q объекты могут также использоваться внутри других Q объектов, для создания еще более сложных запросов.

## __Абстрактные модели django__

Абстрактные модели в Django - это базовые классы моделей, которые не предназначены для создания таблиц в базе данных, а скорее для наследования другими моделями. Абстрактные модели могут содержать общие поля и методы, которые будут наследоваться всеми моделями, которые их наследуют.

Например, если у вас есть несколько моделей, которые имеют общие поля, такие как дата создания, дата изменения и автор, вы можете определить абстрактную модель, которая будет содержать эти поля, а затем наследовать ее в каждой из этих моделей. Это может существенно упростить код и уменьшить дублирование.

Важно отметить, что абстрактные модели не создают свои собственные таблицы в базе данных. Они могут содержать поля, но не могут содержать методы, которые выполняют запросы к базе данных. Если вам нужно определить методы, которые работают с базой данных, вы можете использовать обычные модели Django.

## __unique_together__

`unique_together` - это параметр модели в Django, который позволяет определить уникальное значение для пары или нескольких полей в таблице базы данных. Таким образом, если в таблице есть две строки с одинаковым значением в указанных полях, будет выброшено исключение `IntegrityError`.

Пример использования `unique_together`:

```python
class MyModel(models.Model):
    field1 = models.CharField(max_length=100)
    field2 = models.CharField(max_length=100)

    class Meta:
        unique_together = ['field1', 'field2']
```

В этом примере мы указали, что значения `field1` и `field2` должны быть уникальными вместе. Если мы попытаемся создать объект `MyModel` с уже существующими значениями `field1` и `field2`, то будет выброшено исключение `IntegrityError`.

## __КАСТОМНЫЕ МИГРАЦИИ__

Кастомные миграции - это миграции, которые создаются и изменяют базу данных в соответствии с требованиями конкретного приложения, а не автоматически создаваемые миграции в Django.

Для создания кастомной миграции в Django можно использовать команду `makemigrations <app_name>`. После этого Django создаст файл миграции в каталоге `migrations` в соответствующем приложении. В этом файле вы можете определить свои собственные операции базы данных, которые должны быть выполнены при применении миграции.

Например, если вы хотите добавить новое поле в таблицу базы данных, вы можете создать миграцию следующего вида:

```python
from django.db import migrations, models

class Migration(migrations.Migration):

    dependencies = [
        ('myapp', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='mymodel',
            name='myfield',
            field=models.CharField(max_length=100),
        ),
    ]
```

Здесь мы импортируем модуль `migrations`, создаем класс миграции и определяем список зависимостей для этой миграции. Затем мы определяем список операций, которые должны быть выполнены при применении миграции. В этом примере мы добавляем новое поле `myfield` в модель `MyModel`.

После того, как вы создали кастомную миграцию, вы можете применить ее с помощью команды `migrate <app_name>`. В результате этой команды Django выполнит все операции из файла миграции и обновит базу данных в соответствии с изменениями, которые вы определили.

## __ManyToMany на уровне БД__

Отношение ManyToMany в базах данных реализуется через дополнительную таблицу, которая связывает записи из двух таблиц. Например, если у нас есть таблицы "Студенты" и "Предметы", то ManyToMany отношение между ними означает, что один студент может изучать несколько предметов, а один предмет может изучаться несколькими студентами.

Для реализации ManyToMany отношений в Django ORM используется промежуточная таблица, которая создается автоматически при создании модели с таким отношением. В промежуточной таблице будут храниться id записей из обеих связанных таблиц. По умолчанию в Django ORM промежуточная таблица называется в соответствии с шаблоном "<имя первой таблицы>_<имя второй таблицы>".

В Django ORM можно указать дополнительные атрибуты для промежуточной таблицы через аргумент `through` при определении отношения ManyToMany. Также можно использовать специальный атрибут `related_name`, который позволяет обращаться к связанным объектам в обратном направлении.

## __select/prefetch related__

`select_related` и `prefetch_related` - это два метода в Django ORM, которые используются для оптимизации выполнения запросов к базе данных при работе с связанными объектами.

`select_related` используется для уменьшения количества запросов к базе данных при получении связанных объектов модели. Этот метод загружает связанные объекты вместе с первоначальным запросом, используя конструкцию JOIN в SQL. Например, если у вас есть модель `Order` и модель `Customer`, и связь между ними установлена через внешний ключ `customer`, то при использовании `select_related('customer')` объекты `Customer` будут загружены вместе с объектами `Order` в один запрос к базе данных.

`prefetch_related` используется для загрузки связанных объектов модели отдельно от первоначального запроса, используя дополнительный запрос к базе данных. Он полезен, когда вы хотите получить связанные объекты нескольких моделей, связанных с первоначальной моделью. Например, если у вас есть модель `Book` с множественной связью `ManyToMany` к модели `Author`, и вы хотите получить все книги и всех авторов, связанных с ними, вы можете использовать `prefetch_related('authors')`.

Использование `select_related` и `prefetch_related` может существенно повысить производительность вашего приложения, особенно при работе с большими объемами данных и связанными объектами моделей. Однако, необходимо помнить, что использование этих методов может повлечь за собой более сложные запросы к базе данных, поэтому необходимо выбирать оптимальный подход в зависимости от конкретной задачи.










<pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"></div></div><br class="Apple-interchange-newline"/></pre>
















<pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"></div></div><br class="Apple-interchange-newline"/></pre>







<pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"></div></div><br class="Apple-interchange-newline"/></pre>
